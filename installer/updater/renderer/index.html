<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OwlCloud Updater</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            flex: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
            margin: 10px 0 0 0;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .status-item {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .status-item h3 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        
        .status-item .status {
            font-size: 2em;
            margin: 10px 0;
        }
        
        .status-item .status.installed {
            color: #4ade80;
        }
        
        .status-item .status.not-installed {
            color: #f87171;
        }
        
        .status-item .status.checking {
            color: #fbbf24;
        }
        
        .actions {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn-primary {
            background: #4ade80;
            color: white;
        }
        
        .btn-primary:hover {
            background: #22c55e;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background: #60a5fa;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #3b82f6;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #f87171;
            color: white;
        }
        
        .btn-danger:hover {
            background: #ef4444;
            transform: translateY(-2px);
        }
        
        .btn-outline {
            background: transparent;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-outline:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.show {
            display: block;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            opacity: 0.8;
            font-size: 0.9em;
        }
        
        .version-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .version-info h3 {
            margin: 0 0 10px 0;
        }
        
        .update-available {
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        
        .update-available .btn {
            background: #fbbf24;
            color: #000;
        }
        
        .update-available .btn:hover {
            background: #f59e0b;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px 0 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modal-header h2 {
            margin: 0;
            color: white;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .modal-body {
            padding: 25px;
            color: white;
        }
        
        .modal-footer {
            padding: 0 25px 25px 25px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔄 OwlCloud Updater</h1>
            <p>Manage and update your OwlCloud browser extensions</p>
        </div>

        <div class="version-info" id="versionInfo">
            <h3>📦 Extension Status</h3>
            <div id="currentVersion">Checking version...</div>
        </div>

        <div class="card">
            <h2>🔍 Extension Detection</h2>
            <div class="status-grid" id="statusGrid">
                <div class="status-item">
                    <h3>Google Chrome</h3>
                    <div class="status checking" id="chromeStatus">⏳</div>
                    <div id="chromeDetails">Checking...</div>
                </div>
                <div class="status-item">
                    <h3>Microsoft Edge</h3>
                    <div class="status checking" id="edgeStatus">⏳</div>
                    <div id="edgeDetails">Checking...</div>
                </div>
                <div class="status-item">
                    <h3>Mozilla Firefox</h3>
                    <div class="status checking" id="firefoxStatus">⏳</div>
                    <div id="firefoxDetails">Checking...</div>
                </div>
            </div>
            
            <div class="actions">
                <button class="btn btn-primary" onclick="checkExtensions()">🔍 Refresh Status</button>
                <button class="btn btn-secondary" onclick="checkForUpdates()">🔄 Check Updates</button>
                <button class="btn btn-outline" onclick="checkReleasesNow()">🚀 Check Releases Now</button>
            </div>
        </div>

        <div class="card" id="updateCard" style="display: none;">
            <h2>📦 Updates Available</h2>
            <div id="updateContent"></div>
            <div class="actions">
                <button class="btn btn-primary" onclick="updateAllExtensions()">🔄 Update All</button>
                <button class="btn btn-outline" onclick="dismissUpdate()">Dismiss</button>
            </div>
        </div>

        <div class="card">
            <h2>🔔 Notification Settings</h2>
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
              <input type="checkbox" id="notificationToggle" style="width: 18px; height: 18px;">
              <label for="notificationToggle" style="font-size: 1.1em;">
                Enable system tray notifications for updates
              </label>
            </div>
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px; padding: 12px; background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px;">
              <input type="checkbox" id="autoUpdateToggle" style="width: 18px; height: 18px;">
              <div>
                <label for="autoUpdateToggle" style="font-size: 1.1em; cursor: pointer;">
                  Automatically install updates
                </label>
                <div style="font-size: 0.85em; opacity: 0.8; margin-top: 4px;">
                  When disabled, you'll be asked before installing updates
                </div>
              </div>
            </div>
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <input type="checkbox" id="runOnStartupToggle" style="width: 18px; height: 18px;">
                            <label for="runOnStartupToggle" style="font-size: 1.05em; cursor: pointer;">
                                Run OwlCloud Updater on system startup
                            </label>
                        </div>
            <div style="margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="font-size: 0.9em;">Monitoring Status:</span>
                <span id="monitoringStatus" style="font-weight: bold;">Checking...</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="font-size: 0.9em;">Last Checked:</span>
                <span id="lastChecked" style="font-size: 0.9em;">Never</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="font-size: 0.9em;">Check Interval:</span>
                <select id="checkInterval" style="padding: 2px 4px; border-radius: 4px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                  <option value="300000">5 minutes</option>
                  <option value="900000">15 minutes</option>
                  <option value="1800000">30 minutes</option>
                  <option value="3600000" selected>1 hour</option>
                  <option value="7200000">2 hours</option>
                  <option value="21600000">6 hours</option>
                  <option value="43200000">12 hours</option>
                  <option value="86400000">24 hours</option>
                </select>
              </div>
            </div>
            <p style="font-size: 0.9em; opacity: 0.8; margin: 0;">
              When enabled, the updater will automatically check for new OwlCloud releases and notify you.
            </p>
          </div>

        <div class="card">
            <h2>🌐 Browser Tracking</h2>
            <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 15px;">
              Choose which browsers to monitor for extension updates. Untracked browsers won't be shown in the extension detection list.
            </p>

            <div id="browserTrackingList" style="margin-bottom: 20px;">
              <!-- Browser tracking checkboxes will be populated here -->
            </div>

            <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-top: 15px;">
              <h3 style="font-size: 1.1em; margin-top: 0;">➕ Add Custom Browser</h3>
              <p style="font-size: 0.85em; opacity: 0.8; margin-bottom: 10px;">
                Track extensions in other Chromium-based browsers by selecting the browser executable.
              </p>
              <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="customBrowserName" placeholder="Browser Name (e.g., Brave)"
                  style="flex: 1; padding: 8px; border-radius: 6px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2);">
                <input type="text" id="customBrowserIcon" placeholder="Icon (emoji)" maxlength="2" value="🌐"
                  style="width: 60px; padding: 8px; border-radius: 6px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); text-align: center;">
              </div>
              <div style="margin-bottom: 10px;">
                <button class="btn btn-outline" onclick="browseForBrowser()" style="width: 100%; margin-bottom: 8px;">
                  📁 Browse for Browser Executable
                </button>
                <div id="selectedBrowserPath" style="font-size: 0.85em; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; min-height: 32px; display: flex; align-items: center; opacity: 0.7;">
                  <span id="browserPathText">No browser selected</span>
                </div>
              </div>
              <button class="btn btn-primary" onclick="addCustomBrowser()" style="width: 100%;" id="addBrowserBtn" disabled>➕ Add Browser</button>
            </div>

            <div id="customBrowsersList" style="margin-top: 15px;">
              <!-- Custom browsers will be listed here -->
            </div>
        </div>

        <div class="card">
            <h2>🛠️ Management Actions</h2>
            <div class="actions">
              <button class="btn btn-secondary" onclick="repairInstallation()">🔧 Repair Installation</button>
              <button class="btn btn-danger" onclick="uninstallAllExtensions()">🗑️ Uninstall All</button>
              <button class="btn btn-outline" onclick="openExtensionFolder()">📁 Open Extensions Page</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Processing...</div>
        </div>

        <!-- Notification Setup Modal -->
        <div class="modal" id="notificationSetupModal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>🔔 Enable Notifications?</h2>
                    <button class="modal-close" onclick="closeNotificationSetup()">&times;</button>
                </div>
                <div class="modal-body">
                    <p>Would you like to receive notifications when OwlCloud updates are available?</p>
                    <div style="margin: 20px 0;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-size: 1.1em; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <input type="checkbox" id="setupNotificationToggle" checked style="margin-right: 10px; width: 18px; height: 18px;">
                            <span>Yes, notify me about updates</span>
                        </label>
                    </div>
                    <p style="font-size: 0.9em; opacity: 0.8;">
                        You'll get system tray notifications when new versions are available. You can change this later in the settings.
                    </p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="saveNotificationSetup()">Continue</button>
                </div>
            </div>
        </div>

        <!-- Browser Restart Modal -->
        <div class="modal" id="browserRestartModal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>🔄 Restart Required</h2>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 15px;">OwlCloud extension has been updated successfully!</p>
                    <p style="font-size: 1.1em; font-weight: bold; color: #fbbf24; margin-bottom: 15px;">
                        Please restart your browser to apply the update.
                    </p>
                    <div id="restartBrowsersList" style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <p style="font-size: 0.9em; margin-bottom: 10px;">Updated browsers:</p>
                        <ul id="updatedBrowsers" style="list-style: none; padding: 0; margin: 0;">
                        </ul>
                    </div>
                    <p style="font-size: 0.85em; opacity: 0.7;">
                        The extension won't be updated until you restart. You can continue using your current version for now.
                    </p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="closeBrowserRestartModal()">Got it</button>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>OwlCloud Updater v1.0.0 • Made with ❤️ for D&D players</p>
            <button class="btn btn-outline" id="quitBtn" style="margin-top: 10px;">Quit</button>
        </div>
    </div>

        <script>
            // Wire notification settings UI
            (async function() {
                try {
                    const settings = await window.electronAPI.getNotificationSettings();
                    if (settings) {
                        document.getElementById('notificationToggle').checked = !!settings.enabled;
                        document.getElementById('autoUpdateToggle').checked = !!settings.autoUpdate;
                        document.getElementById('runOnStartupToggle').checked = !!settings.runOnStartup || !!settings.startWithWindows || false;
                        document.getElementById('checkInterval').value = settings.checkInterval || '3600000';
                        document.getElementById('lastChecked').textContent = settings.lastChecked || 'Never';
                    }

                    const saveSettings = async () => {
                        const newSettings = {
                            enabled: document.getElementById('notificationToggle').checked,
                            autoUpdate: document.getElementById('autoUpdateToggle').checked,
                            runOnStartup: document.getElementById('runOnStartupToggle').checked,
                            checkInterval: Number(document.getElementById('checkInterval').value)
                        };
                        await window.electronAPI.saveNotificationSettings(newSettings);
                    };

                    document.getElementById('notificationToggle').addEventListener('change', saveSettings);
                    document.getElementById('autoUpdateToggle').addEventListener('change', saveSettings);
                    document.getElementById('runOnStartupToggle').addEventListener('change', saveSettings);
                    document.getElementById('checkInterval').addEventListener('change', saveSettings);
                } catch (e) {
                    console.warn('Failed to initialize updater settings UI:', e);
                }
            })();
        </script>

    <script>
        // Extension detection
        async function checkExtensions() {
            showLoading(true);
            try {
                const result = await window.electronAPI.detectExtensions();
                if (result.success) {
                    updateStatusDisplay(result);
                } else {
                    showError('Failed to detect extensions: ' + result.error);
                }
            } catch (error) {
                showError('Error checking extensions: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Browser tracking management
        async function loadBrowserTracking() {
            try {
                const result = await window.electronAPI.getTrackedBrowsers();
                if (result.success) {
                    updateBrowserTrackingUI(result.trackedBrowsers, result.customBrowsers);
                }
            } catch (error) {
                console.error('Failed to load browser tracking:', error);
            }
        }

        function updateBrowserTrackingUI(trackedBrowsers, customBrowsers) {
            const trackingList = document.getElementById('browserTrackingList');
            const customList = document.getElementById('customBrowsersList');

            // Standard browsers
            const standardBrowsers = [
                { id: 'chrome', name: 'Google Chrome' },
                { id: 'edge', name: 'Microsoft Edge' },
                { id: 'firefox', name: 'Mozilla Firefox' }
            ];

            trackingList.innerHTML = '';
            standardBrowsers.forEach(browser => {
                const isTracked = trackedBrowsers.includes(browser.id);
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; margin-bottom: 8px; background: rgba(255,255,255,0.05); border-radius: 6px;';
                div.innerHTML = `
                    <input type="checkbox" id="track-${browser.id}" ${isTracked ? 'checked' : ''}
                        onchange="toggleBrowserTracking('${browser.id}')"
                        style="width: 18px; height: 18px; cursor: pointer;">
                    <label for="track-${browser.id}" style="cursor: pointer; flex: 1;">${browser.name}</label>
                `;
                trackingList.appendChild(div);
            });

            // Custom browsers
            customList.innerHTML = '';
            if (customBrowsers && customBrowsers.length > 0) {
                const header = document.createElement('h3');
                header.style.cssText = 'font-size: 1.1em; margin: 20px 0 10px 0;';
                header.textContent = '🎯 Custom Browsers';
                customList.appendChild(header);

                customBrowsers.forEach(browser => {
                    const isTracked = trackedBrowsers.includes(browser.id);
                    const div = document.createElement('div');
                    div.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; margin-bottom: 8px; background: rgba(255,255,255,0.05); border-radius: 6px;';
                    div.innerHTML = `
                        <input type="checkbox" id="track-${browser.id}" ${isTracked ? 'checked' : ''}
                            onchange="toggleBrowserTracking('${browser.id}')"
                            style="width: 18px; height: 18px; cursor: pointer;">
                        <label for="track-${browser.id}" style="cursor: pointer; flex: 1;">
                            ${browser.icon || '🌐'} ${browser.name} <span style="opacity: 0.6; font-size: 0.85em;">(${browser.fileName || browser.appName || 'Unknown'})</span>
                        </label>
                        <button onclick="removeCustomBrowser('${browser.id}')"
                            style="background: rgba(248,113,113,0.3); color: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em;">
                            🗑️ Remove
                        </button>
                    `;
                    customList.appendChild(div);
                });
            }
        }

        async function toggleBrowserTracking(browserName) {
            try {
                const result = await window.electronAPI.toggleBrowserTracking(browserName);
                if (result.success) {
                    // Refresh extension detection
                    checkExtensions();
                } else {
                    showError('Failed to toggle browser tracking: ' + result.error);
                }
            } catch (error) {
                showError('Error toggling browser tracking: ' + error.message);
            }
        }

        // Store the selected browser executable path
        let selectedBrowserPath = null;

        async function browseForBrowser() {
            try {
                const result = await window.electronAPI.browseForBrowser();
                if (result.success && !result.canceled) {
                    selectedBrowserPath = result.filePath;

                    // Update UI
                    document.getElementById('browserPathText').textContent = result.filePath;
                    document.getElementById('selectedBrowserPath').style.opacity = '1';

                    // Auto-fill browser name if empty
                    const nameInput = document.getElementById('customBrowserName');
                    if (!nameInput.value.trim()) {
                        nameInput.value = result.suggestedName;
                    }

                    // Enable add button
                    document.getElementById('addBrowserBtn').disabled = false;
                } else if (result.error) {
                    showError('Failed to browse for browser: ' + result.error);
                }
            } catch (error) {
                showError('Error browsing for browser: ' + error.message);
            }
        }

        async function addCustomBrowser() {
            const name = document.getElementById('customBrowserName').value.trim();
            const icon = document.getElementById('customBrowserIcon').value.trim() || '🌐';

            if (!name) {
                showError('Please enter a browser name');
                return;
            }

            if (!selectedBrowserPath) {
                showError('Please select a browser executable');
                return;
            }

            try {
                const result = await window.electronAPI.addCustomBrowser({
                    name,
                    executablePath: selectedBrowserPath,
                    icon
                });

                if (result.success) {
                    showSuccess(`Added ${name} to tracked browsers`);
                    // Clear form
                    document.getElementById('customBrowserName').value = '';
                    document.getElementById('customBrowserIcon').value = '🌐';
                    document.getElementById('browserPathText').textContent = 'No browser selected';
                    document.getElementById('selectedBrowserPath').style.opacity = '0.7';
                    document.getElementById('addBrowserBtn').disabled = true;
                    selectedBrowserPath = null;

                    // Refresh UI
                    await loadBrowserTracking();
                    await checkExtensions();
                } else {
                    showError('Failed to add custom browser: ' + result.error);
                }
            } catch (error) {
                showError('Error adding custom browser: ' + error.message);
            }
        }

        async function removeCustomBrowser(browserId) {
            if (!confirm('Remove this custom browser from tracking?')) {
                return;
            }

            try {
                const result = await window.electronAPI.removeCustomBrowser(browserId);
                if (result.success) {
                    showSuccess('Custom browser removed');
                    // Refresh UI
                    await loadBrowserTracking();
                    await checkExtensions();
                } else {
                    showError('Failed to remove custom browser: ' + result.error);
                }
            } catch (error) {
                showError('Error removing custom browser: ' + error.message);
            }
        }

        // Notification setup functions
        function showNotificationSetup() {
            document.getElementById('notificationSetupModal').style.display = 'flex';
        }

        function closeNotificationSetup() {
            document.getElementById('notificationSetupModal').style.display = 'none';
        }

        async function saveNotificationSetup() {
            const enabled = document.getElementById('setupNotificationToggle').checked;
            
            try {
                const result = await window.electronAPI.saveNotificationSettings({ enabled: enabled });
                
                if (result.success) {
                    // Update main UI toggle
                    const mainToggle = document.getElementById('notificationToggle');
                    if (mainToggle) {
                        mainToggle.checked = enabled;
                    }
                    
                    // Close modal
                    closeNotificationSetup();
                    
                    // Mark first run as complete
                    await window.electronAPI.completeFirstRun();
                    
                    // Show success message
                    if (enabled) {
                        showSuccess('Notifications enabled! You will be notified about updates.');
                    } else {
                        showSuccess('Notifications disabled. You can enable them in settings anytime.');
                    }
                } else {
                    showError('Failed to save notification settings: ' + result.error);
                }
            } catch (error) {
                showError('Error saving notification settings: ' + error.message);
            }
        }

        // Listen for notification setup request from main process
        window.addEventListener('DOMContentLoaded', () => {
            window.electronAPI.onShowNotificationSetup(() => {
                showNotificationSetup();
            });

            window.electronAPI.onNotificationSettingsChanged((event, settings) => {
                // Update UI if notification settings change from tray menu
                const notificationToggle = document.getElementById('notificationToggle');
                if (notificationToggle) {
                    notificationToggle.checked = settings.enabled;
                }
            });

            window.electronAPI.onCheckUpdatesRequested(() => {
                // Trigger update check when requested from tray
                checkForUpdates();
            });

            // Load notification settings
            loadNotificationSettings();
        });

        async function loadNotificationSettings() {
            try {
                const result = await window.electronAPI.getNotificationSettings();
                if (result.success) {
                    const notificationToggle = document.getElementById('notificationToggle');
                    const autoUpdateToggle = document.getElementById('autoUpdateToggle');

                    if (notificationToggle) {
                        notificationToggle.checked = result.settings.enabled;
                    }
                    if (autoUpdateToggle) {
                        autoUpdateToggle.checked = result.settings.autoUpdate || false;
                    }
                }
            } catch (error) {
                console.error('Failed to load notification settings:', error);
            }
        }

        // Handle notification toggle changes
        document.getElementById('notificationToggle')?.addEventListener('change', async (event) => {
            const enabled = event.target.checked;

            try {
                const result = await window.electronAPI.saveNotificationSettings({ enabled: enabled });
                if (!result.success) {
                    showError('Failed to save notification settings: ' + result.error);
                    // Revert the checkbox
                    event.target.checked = !enabled;
                } else {
                    // Update monitoring status display
                    updateMonitoringStatus();
                }
            } catch (error) {
                showError('Error saving notification settings: ' + error.message);
                event.target.checked = !enabled;
            }
        });

        // Handle auto-update toggle changes
        document.getElementById('autoUpdateToggle')?.addEventListener('change', async (event) => {
            const autoUpdate = event.target.checked;

            try {
                const result = await window.electronAPI.saveNotificationSettings({ autoUpdate: autoUpdate });
                if (!result.success) {
                    showError('Failed to save auto-update settings: ' + result.error);
                    // Revert the checkbox
                    event.target.checked = !autoUpdate;
                } else {
                    showSuccess(autoUpdate ? 'Auto-updates enabled' : 'Auto-updates disabled');
                }
            } catch (error) {
                showError('Error saving auto-update settings: ' + error.message);
                event.target.checked = !autoUpdate;
            }
        });

        // Handle check interval changes
        document.getElementById('checkInterval')?.addEventListener('change', async (event) => {
            const interval = parseInt(event.target.value);
            
            try {
                const result = await window.electronAPI.setCheckInterval(interval);
                if (!result.success) {
                    showError('Failed to update check interval: ' + result.error);
                    // Revert the select
                    event.target.value = '3600000'; // Default to 1 hour
                } else {
                    showSuccess('Check interval updated successfully');
                }
            } catch (error) {
                showError('Error updating check interval: ' + error.message);
                event.target.value = '3600000';
            }
        });

        // Monitoring status functions
        async function updateMonitoringStatus() {
            try {
                const result = await window.electronAPI.getMonitoringStatus();
                if (result.success) {
                    const statusElement = document.getElementById('monitoringStatus');
                    const lastCheckedElement = document.getElementById('lastChecked');
                    const intervalElement = document.getElementById('checkInterval');
                    
                    if (statusElement) {
                        statusElement.textContent = result.isMonitoring ? '🟢 Active' : '🔴 Inactive';
                        statusElement.style.color = result.isMonitoring ? '#4ade80' : '#f87171';
                    }
                    
                    if (lastCheckedElement) {
                        if (result.lastChecked) {
                            const lastChecked = new Date(result.lastChecked);
                            const now = new Date();
                            const diffMs = now - lastChecked;
                            const diffMins = Math.floor(diffMs / 60000);
                            
                            if (diffMins < 1) {
                                lastCheckedElement.textContent = 'Just now';
                            } else if (diffMins < 60) {
                                lastCheckedElement.textContent = `${diffMins} minutes ago`;
                            } else if (diffMins < 1440) {
                                lastCheckedElement.textContent = `${Math.floor(diffMins / 60)} hours ago`;
                            } else {
                                lastCheckedElement.textContent = lastChecked.toLocaleDateString();
                            }
                        } else {
                            lastCheckedElement.textContent = 'Never';
                        }
                    }
                    
                    if (intervalElement) {
                        intervalElement.value = result.checkInterval.toString();
                    }
                }
            } catch (error) {
                console.error('Failed to get monitoring status:', error);
            }
        }

        // Immediate release check function
        async function checkReleasesNow() {
            showLoading(true);
            try {
                const result = await window.electronAPI.checkReleasesNow();
                if (result.success) {
                    showSuccess('Release check completed!');
                    updateMonitoringStatus();
                    
                    // If there's a new release, show it
                    if (result.result.isNew) {
                        showUpdateCard(result.result.release);
                    } else {
                        showSuccess('You have the latest version!');
                    }
                } else {
                    showError('Failed to check releases: ' + result.error);
                }
            } catch (error) {
                showError('Error checking releases: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Listen for new release notifications from main process
        window.addEventListener('DOMContentLoaded', () => {
            window.electronAPI.onNewReleaseAvailable((event, release) => {
                // Show update card with new release info
                showUpdateCard(release);
            });

            // Update monitoring status periodically
            setInterval(updateMonitoringStatus, 30000); // Update every 30 seconds
        });

        function showUpdateCard(release) {
            const updateCard = document.getElementById('updateCard');
            const updateContent = document.getElementById('updateContent');
            
            updateCard.style.display = 'block';
            updateCard.classList.add('update-available');
            
            updateContent.innerHTML = `
                <p><strong>🎉 New version available!</strong></p>
                <p><strong>${release.name}</strong> (Version ${release.version})</p>
                <p style="font-size: 0.9em; opacity: 0.8; margin-top: 5px;">
                    Released: ${new Date(release.publishedAt).toLocaleDateString()}
                </p>
                <p style="font-size: 0.85em; margin-top: 8px; max-height: 100px; overflow-y: auto; opacity: 0.9;">
                    ${release.body ? release.body.substring(0, 200) + (release.body.length > 200 ? '...' : '') : 'No release notes available.'}
                </p>
            `;
        }

        function updateStatusDisplay(data) {
            const statusGrid = document.getElementById('statusGrid');
            const { results, trackedBrowsers = [], customBrowsers = [] } = data;

            // Clear existing status items
            statusGrid.innerHTML = '';

            const browserMeta = {
                chrome: { name: 'Google Chrome', icon: '' },
                edge: { name: 'Microsoft Edge', icon: '' },
                firefox: { name: 'Mozilla Firefox', icon: '' }
            };

            // Add standard browsers
            trackedBrowsers.forEach(browserKey => {
                if (browserKey.startsWith('custom-')) {
                    // Skip custom browsers, they'll be added separately
                    return;
                }

                const meta = browserMeta[browserKey];
                if (!meta) return;

                const isInstalled = results[browserKey];
                const statusItem = document.createElement('div');
                statusItem.className = 'status-item';
                statusItem.innerHTML = `
                    <h3>${meta.name}</h3>
                    <div class="status ${isInstalled ? 'installed' : 'not-installed'}" id="${browserKey}Status">
                        ${isInstalled ? '✅' : '❌'}
                    </div>
                    <div id="${browserKey}Details">${isInstalled ? 'Extension installed' : 'Extension not found'}</div>
                `;
                statusGrid.appendChild(statusItem);
            });

            // Add custom browsers
            customBrowsers.forEach(browser => {
                if (!trackedBrowsers.includes(browser.id)) return;

                const isInstalled = results[browser.id];
                const statusItem = document.createElement('div');
                statusItem.className = 'status-item';
                statusItem.innerHTML = `
                    <h3>${browser.icon || '🌐'} ${browser.name}</h3>
                    <div class="status ${isInstalled ? 'installed' : 'not-installed'}" id="${browser.id}Status">
                        ${isInstalled ? '✅' : '❌'}
                    </div>
                    <div id="${browser.id}Details">${isInstalled ? 'Extension installed' : 'Extension not found'}</div>
                `;
                statusGrid.appendChild(statusItem);
            });

            // If no browsers are tracked
            if (statusGrid.children.length === 0) {
                statusGrid.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.7;">No browsers are being tracked. Add browsers in the Browser Tracking section below.</div>';
            }
        }

        // Update checking
        async function checkForUpdates() {
            showLoading(true);
            try {
                const result = await window.electronAPI.checkUpdates();
                if (result.success) {
                    updateVersionInfo(result.updates);
                } else {
                    showError('Failed to check for updates: ' + result.error);
                }
            } catch (error) {
                showError('Error checking updates: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function updateVersionInfo(updates) {
            const versionInfo = document.getElementById('versionInfo');
            const currentVersion = updates.version || '1.0.0';
            
            versionInfo.innerHTML = `
                <h3>📦 Extension Status</h3>
                <div>Current version: v${currentVersion}</div>
                <div style="font-size: 0.9em; margin-top: 5px; opacity: 0.8;">
                    Latest available: v${updates.version}
                </div>
            `;
            
            // Show update card if newer version available
            if (updates.version && isNewerVersion(currentVersion, updates.version)) {
                showUpdateCard(updates);
            }
        }

        function isNewerVersion(current, latest) {
            // Simple version comparison (assumes semantic versioning)
            const currentParts = current.split('.').map(Number);
            const latestParts = latest.split('.').map(Number);
            
            for (let i = 0; i < Math.max(currentParts.length, latestParts.length); i++) {
                const current = currentParts[i] || 0;
                const latest = latestParts[i] || 0;
                if (latest > current) return true;
                if (latest < current) return false;
            }
            return false;
        }

        function showUpdateCard(updates) {
            const updateCard = document.getElementById('updateCard');
            const updateContent = document.getElementById('updateContent');
            
            updateCard.style.display = 'block';
            updateCard.classList.add('update-available');
            
            updateContent.innerHTML = `
                <p><strong>New version available!</strong></p>
                <p>OwlCloud v${updates.version} is ready to download.</p>
                <p style="font-size: 0.9em; opacity: 0.8;">
                    Release notes and improvements will be available after update.
                </p>
            `;
        }

        function dismissUpdate() {
            document.getElementById('updateCard').style.display = 'none';
        }

        // Management actions
        async function updateAllExtensions() {
            showLoading(true);
            const updatedBrowsers = [];

            try {
                // This would trigger updates for all detected browsers
                const browsers = ['chrome', 'firefox'];
                for (const browser of browsers) {
                    const result = await window.electronAPI.updateExtension(browser);
                    if (result.success) {
                        updatedBrowsers.push(browser);
                    }
                }

                if (updatedBrowsers.length > 0) {
                    showBrowserRestartModal(updatedBrowsers);
                } else {
                    showError('No extensions were updated. Check the console for errors.');
                }
            } catch (error) {
                showError('Failed to update extensions: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Show browser restart modal
        function showBrowserRestartModal(browsers) {
            const modal = document.getElementById('browserRestartModal');
            const browsersList = document.getElementById('updatedBrowsers');

            if (!modal || !browsersList) return;

            browsersList.innerHTML = '';
            browsers.forEach(browser => {
                const li = document.createElement('li');
                li.style.cssText = 'padding: 8px 12px; background: rgba(255,255,255,0.05); margin: 5px 0; border-radius: 6px; display: flex; align-items: center; gap: 10px;';

                const browserName = browser === 'chrome' ? 'Google Chrome' :
                                   browser === 'firefox' ? 'Mozilla Firefox' : browser;

                li.innerHTML = `
                    <span style="font-size: 1.3em;">🔄</span>
                    <span style="font-weight: 500;">${browserName}</span>
                `;
                browsersList.appendChild(li);
            });

            modal.style.display = 'flex';
        }

        function closeBrowserRestartModal() {
            const modal = document.getElementById('browserRestartModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function repairInstallation() {
            if (!confirm('Repair installation? This will re-detect and update all tracked browser extensions.')) {
                return;
            }

            showLoading(true);
            try {
                // Re-check all extensions
                await checkExtensions();
                // Attempt to update all tracked browsers
                const result = await window.electronAPI.getTrackedBrowsers();
                if (result.success) {
                    const browsers = result.trackedBrowsers.filter(b => ['chrome', 'firefox'].includes(b));
                    for (const browser of browsers) {
                        try {
                            await window.electronAPI.updateExtension(browser);
                        } catch (error) {
                            console.error(`Failed to repair ${browser}:`, error);
                        }
                    }
                }
                showSuccess('Installation repair completed. Check the extension status above.');
            } catch (error) {
                showError('Failed to repair installation: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        async function uninstallAllExtensions() {
            const confirmed = confirm('Are you sure you want to uninstall OwlCloud from all browsers? This will remove the extension and all its data.');
            if (!confirmed) return;

            showLoading(true);
            try {
                const result = await window.electronAPI.getTrackedBrowsers();
                if (result.success) {
                    const browsers = result.trackedBrowsers.filter(b => ['chrome', 'edge', 'firefox'].includes(b));
                    for (const browser of browsers) {
                        await window.electronAPI.uninstallExtension(browser);
                    }
                }
                showSuccess('Extension uninstallation initiated. Restart your browsers to complete the removal.');
            } catch (error) {
                showError('Failed to uninstall extensions: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        function openExtensionFolder() {
            // Open browser extension management pages
            const options = [
                { name: 'Chrome Extensions', url: 'chrome://extensions' },
                { name: 'Edge Extensions', url: 'edge://extensions' },
                { name: 'Firefox Add-ons', url: 'about:addons' },
                { name: 'GitHub Releases', url: 'https://github.com/CarmaNayeli/rollCloud/releases' }
            ];

            const choice = confirm('Open browser extension pages?\n\nOK = Browser extension pages\nCancel = GitHub releases page');

            if (choice) {
                // Try to open browser-specific pages
                showSuccess('Opening browser extension pages...\n\nChrome: chrome://extensions\nEdge: edge://extensions\nFirefox: about:addons\n\nCopy these URLs into your browser address bar.');
            } else {
                window.electronAPI.openExternal('https://github.com/CarmaNayeli/rollCloud/releases');
            }
        }

        // UI helpers
        function showLoading(show) {
            document.getElementById('loading').classList.toggle('show', show);
        }

        function showSuccess(message) {
            alert('✅ ' + message);
        }

        function showError(message) {
            alert('❌ ' + message);
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            loadBrowserTracking();
            checkExtensions();
            loadNotificationSettings();
            updateMonitoringStatus();

            // Listen for notification setup request from main process
            window.electronAPI.onShowNotificationSetup(() => {
                showNotificationSetup();
            });

            window.electronAPI.onNotificationSettingsChanged((event, settings) => {
                // Update UI if notification settings change from tray menu
                const notificationToggle = document.getElementById('notificationToggle');
                if (notificationToggle) {
                    notificationToggle.checked = settings.enabled;
                }
                updateMonitoringStatus();
            });

            window.electronAPI.onCheckUpdatesRequested(() => {
                // Trigger update check when requested from tray
                checkForUpdates();
            });

            // Listen for new release notifications from main process
            window.electronAPI.onNewReleaseAvailable((event, release) => {
                // Show update card with new release info
                showUpdateCard(release);
            });

            // Listen for auto-update events
            window.electronAPI.onAutoUpdateStarted?.((event, release) => {
                showLoading(true);
                showSuccess(`Auto-update started: downloading version ${release.version}...`);
            });

            window.electronAPI.onAutoUpdateCompleted?.((event, release) => {
                showLoading(false);
                showBrowserRestartModal(['chrome', 'firefox']);
            });

            // Update monitoring status periodically
            setInterval(updateMonitoringStatus, 30000); // Update every 30 seconds
        });
    </script>
</body>
</html>
