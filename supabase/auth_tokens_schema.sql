-- Supabase SQL Schema for RollCloud Auth Token Persistence
-- Run this in your Supabase SQL Editor to create the auth_tokens table

-- Create the auth_tokens table
CREATE TABLE IF NOT EXISTS public.auth_tokens (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL UNIQUE,
    dicecloud_token TEXT NOT NULL,
    username VARCHAR(255) DEFAULT 'DiceCloud User',
    user_id_dicecloud VARCHAR(255),
    token_expires TIMESTAMP WITH TIME ZONE,
    browser_info JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_auth_tokens_user_id ON public.auth_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_auth_tokens_updated_at ON public.auth_tokens(updated_at);

-- Add comments for documentation
COMMENT ON TABLE public.auth_tokens IS 'Stores DiceCloud authentication tokens for cross-session persistence';
COMMENT ON COLUMN public.auth_tokens.user_id IS 'Browser fingerprint-based user identifier';
COMMENT ON COLUMN public.auth_tokens.dicecloud_token IS 'Encrypted DiceCloud authentication token';
COMMENT ON COLUMN public.auth_tokens.username IS 'DiceCloud username';
COMMENT ON COLUMN public.auth_tokens.user_id_dicecloud IS 'DiceCloud user ID';
COMMENT ON COLUMN public.auth_tokens.token_expires IS 'Token expiration timestamp';
COMMENT ON COLUMN public.auth_tokens.browser_info IS 'Browser metadata for debugging';

-- Enable Row Level Security (RLS)
ALTER TABLE public.auth_tokens ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
-- Allow users to read/write their own tokens based on user_id
CREATE POLICY "Users can view own tokens" ON public.auth_tokens
    FOR SELECT USING (true);

CREATE POLICY "Users can insert own tokens" ON public.auth_tokens
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update own tokens" ON public.auth_tokens
    FOR UPDATE USING (true);

CREATE POLICY "Users can delete own tokens" ON public.auth_tokens
    FOR DELETE USING (true);

-- Create a function to automatically update the updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create a trigger to automatically update updated_at
CREATE TRIGGER handle_auth_tokens_updated_at
    BEFORE UPDATE ON public.auth_tokens
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- Grant necessary permissions
GRANT ALL ON public.auth_tokens TO anon;
GRANT ALL ON public.auth_tokens TO authenticated;

-- Optional: Create a view for debugging/administration
CREATE OR REPLACE VIEW public.auth_tokens_debug AS
SELECT 
    id,
    user_id,
    username,
    user_id_dicecloud,
    token_expires,
    browser_info->>'userAgent' as browser,
    browser_info->>'timestamp' as last_seen,
    created_at,
    updated_at,
    CASE 
        WHEN token_expires IS NOT NULL AND token_expires < NOW() THEN 'expired'
        WHEN token_expires IS NULL THEN 'no_expiry'
        ELSE 'active'
    END as status
FROM public.auth_tokens
ORDER BY updated_at DESC;

COMMENT ON VIEW public.auth_tokens_debug IS 'Debug view for auth tokens with status information';
